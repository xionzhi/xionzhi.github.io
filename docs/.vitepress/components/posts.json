[{"title":"test","author":"xionzhi","date":"2022-12-20","showAccessNumber":true,"categories":["测试"],"tags":["标签1","标签2","标签3"],"excerpt":"","link":"/posts/test.html"},{"title":"Iterables(可迭代对象) Iterators(迭代器) Generators(生成器)","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":"在python中有许多概念在探究细节差异的时候是容易混淆的，比如:\n- a container(容器) - an iterable(可迭代对象) - an iterator(迭代器) - a generator(生成器) - a generator expression(各种生成式 列表生成式和字典生成式之类) - a {list, set, dict} comprehension(对列表集合字典的理解) ","link":"/posts/Iterables(可迭代对象) Iterators(迭代器) Generators(生成器).html"},{"title":"Python Redis BitMap储存用户签到","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":"Redis提供的数据类型位图BitMap，每个bit位对应0和1两个状态。虽然内部还是采用String类型存储，但Redis提供了一些指令用于直接操作BitMap，可以把它看作一个bit数组，数组的下标就是偏移量。\n它的优点是内存开销小，效率高且操作简单，很适合用于签到这类场景。缺点在于位计算和位表示数值的局限。如果要用位来做业务数据记录，就不要在意value的值。 ","link":"/posts/Python Redis BitMap储存用户签到.html"},{"title":"Python多字段排序和分组","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":" inventory = [{'key': 'inventory', 'value': 3, 'store': 'A1', 'discount': 1}, {'key': 'banana', 'value': 2, 'store': 'A1', 'discount': 1}, {'key': 'pear', 'value': 5, 'store': 'A1', 'discount': 2}, {'key': 'orange', 'value': 1, 'store': 'A1', 'discount': 2}, {'key': 'litchi', 'value': 4, 'store': 'A2', 'discount': 2}, {'key': 'grape', 'value': 6, 'store': 'A2', 'discount': 2}, {'key': 'watermelon', 'value': 7, 'store': 'A2', 'discount': 1}, {'key': 'plum', 'value': 8, 'store': 'A2', 'discount': 1},] ","link":"/posts/Python多字段排序和分组.html"},{"title":"Python标准运算符替代函数","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":" from operator import *\n# 1. 绝对值 abs(100)  # 100 abs(-100)  # 100 abs(2j + 1)  # 2.23606797749979, 返回复数的绝对值 (a^2+b^2)**0.5\n# 2. 加法 add(100, 1)  # 101, a + b\n# 3. 按位与 and_(True, [1])  # 1, a & b and_({1,2,3}, {2,3,4})  # {2, 3}, \n# 4. 连接 concat('abc', '123')  # abc123, seq1 + seq2 concat([1, 2], [3])  # [1,2,3]\n# 5. 包含检测 contains([1, 2], 1)  # True, obj in seq ","link":"/posts/Python标准运算符替代函数.html"},{"title":"functools高阶函数和可调用对象上的操作","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":"一个为函数提供缓存功能的装饰器，缓存 *maxsize* 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。\n```python @lru_cache def test_lru_cache(self, a=None, b=None): time.sleep(1) return f'{a}: {b}: {time.time()}'\nprint(tf.test_lru_cache(a=1, b=2)) print(tf.test_lru_cache(a=1, b=2)) print(tf.test_lru_cache(a=1, b=2)) print(tf.test_lru_cache(a=1, b=2))\n# 1: 2: 1663580739.8764858 # 1: 2: 1663580739.8764858 # 1: 2: 1663580739.8764858 # 1: 2: 1663580739.8764858 ``` ","link":"/posts/functools高阶函数和可调用对象上的操作.html"},{"title":"python3.6之后字典类型为什么是有序的","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":"有序字典设计使用基于[**Raymond Hettinger**](https://mail.python.org/pipermail/python-dev/2012-December/123028.html) 提出的`More compact dictionaries with faster iteration`， 最开始由 [**PyPy**](https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html) 实现。`dict()`与 `Python 3.5` 相比，新版本的内存使用量减少了`20%` 到 `25%`，从 `Python 3.8` 开始，字典还支持反向迭代`reversed`。","link":"/posts/python3.6之后字典类型为什么是有序的.html"},{"title":"关于Python默认参数的一个大坑","author":"xionzhi","date":"2023-01-05","showAccessNumber":true,"categories":["python"],"tags":["python"],"excerpt":" 定义一个玩家类`Player`, 有名字`name`和道具`items`两个属性\npython class Player: def __init__(self, name, items): self.name = name self.items = items\n\np1 = Player('王大发', []) p2 = Player('陈不发', []) p3 = Player('马发腾', ['金色传说'])\n\n初始化两个玩家`p1 p2`, 此时发现大部分玩家创建时道具`items`是空的, 所以就有了以下代码 ","link":"/posts/关于Python默认参数的一个大坑.html"}]